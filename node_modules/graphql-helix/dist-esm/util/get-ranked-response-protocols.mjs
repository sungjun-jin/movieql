function normalizeValue(str) {
    return str.split(";")[0].trim();
}
/**
 * parses an accept header string '"application/json, text/event-stream"' into an array of strings '["application/json", "text/event-stream"]'
 * @param acceptHeader accept header string as sent by client
 * @returns
 */
function parseAcceptHeader(acceptHeader) {
    return acceptHeader.split(",").map(normalizeValue);
}
/**
 * Returns a map of ranked protocols which can be used for determining teh protocol for sending a response to the client.
 * @param acceptHeader accept header string as sent by client
 * @param contentTypeHeader content-type header string as sent by client
 */
export function getRankedResponseProtocols(acceptHeader, contentTypeHeader) {
    const rankedProtocols = {
        "application/graphql+json": -1,
        "application/json": -1 /* LEGACY */,
        "text/event-stream": -1,
        "multipart/mixed": -1,
    };
    /**
     * In case no acceptHeader has been sent by the client, the response protocol is determined by trying to mirror the incoming content-type.
     * This works for 'application/graphql+json' and 'application/json'.
     */
    if (typeof acceptHeader !== "string") {
        // if no accept is provided we rank up the content-type
        if (typeof contentTypeHeader === "string") {
            const normalizedContentType = normalizeValue(contentTypeHeader);
            if (normalizedContentType in rankedProtocols) {
                rankedProtocols[normalizedContentType]++;
            }
        }
        return rankedProtocols;
    }
    /**
     * In case no acceptHeader has been sent by the client, we need to parse it and then create ranking of what suits the client best.
     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept
     */
    const supportedProtocols = parseAcceptHeader(acceptHeader);
    let index = 0;
    for (const protocol of supportedProtocols) {
        if (protocol in rankedProtocols) {
            rankedProtocols[protocol] = index;
            index++;
        }
    }
    return rankedProtocols;
}
