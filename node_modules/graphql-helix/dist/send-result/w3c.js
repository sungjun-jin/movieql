"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResponse = exports.getPushResponse = exports.getMultipartResponse = exports.getRegularResponse = void 0;
const errors_1 = require("../errors");
const utils_1 = require("./utils");
function getRegularResponse(responseResult, Response, transformResult = utils_1.DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = [];
    for (const { name, value } of responseResult.headers) {
        headersInit.push([name, value]);
    }
    const responseInit = {
        headers: headersInit,
        status: responseResult.status,
    };
    const transformedResult = transformResult(responseResult.payload);
    const responseBody = JSON.stringify(transformedResult);
    return new Response(responseBody, responseInit);
}
exports.getRegularResponse = getRegularResponse;
function getMultipartResponse(multipartResult, Response, ReadableStream, transformResult = utils_1.DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        "Connection": "keep-alive",
        "Content-Type": 'multipart/mixed; boundary="-"',
        "Transfer-Encoding": "chunked",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    const readableStream = new ReadableStream({
        async start(controller) {
            controller.enqueue(`---`);
            await multipartResult.subscribe(patchResult => {
                const transformedResult = transformResult(patchResult);
                const chunk = JSON.stringify(transformResult(transformedResult));
                const data = ["", "Content-Type: application/json; charset=utf-8", "Content-Length: " + String(chunk.length), "", chunk];
                if (patchResult.hasNext) {
                    data.push("---");
                }
                controller.enqueue(data.join("\r\n"));
            });
            controller.enqueue('\r\n-----\r\n');
            controller.close();
        },
        cancel() {
            multipartResult.unsubscribe();
        }
    });
    return new Response(readableStream, responseInit);
}
exports.getMultipartResponse = getMultipartResponse;
function getPushResponse(pushResult, Response, ReadableStream, transformResult = utils_1.DEFAULT_TRANSFORM_RESULT_FN) {
    const headersInit = {
        "Content-Type": "text/event-stream",
        "Connection": "keep-alive",
        "Cache-Control": "no-cache",
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    const readableStream = new ReadableStream({
        async start(controller) {
            await pushResult.subscribe(result => {
                controller.enqueue(`data: ${JSON.stringify(transformResult(result))}\n\n`);
            });
            controller.close();
        },
        cancel() {
            pushResult.unsubscribe();
        }
    });
    return new Response(readableStream, responseInit);
}
exports.getPushResponse = getPushResponse;
function getResponse(result, Response, ReadableStream, transformResult = utils_1.DEFAULT_TRANSFORM_RESULT_FN) {
    switch (result.type) {
        case "RESPONSE":
            return getRegularResponse(result, Response, transformResult);
        case "MULTIPART_RESPONSE":
            return getMultipartResponse(result, Response, ReadableStream, transformResult);
        case "PUSH":
            return getPushResponse(result, Response, ReadableStream, transformResult);
        default:
            throw new errors_1.HttpError(500, "Cannot process result.");
    }
}
exports.getResponse = getResponse;
